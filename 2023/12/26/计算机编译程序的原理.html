<h1 id="1-编译-汇编-链接">1. 编译, 汇编, 链接</h1>
<p><img src="https://s2.loli.net/2023/11/16/iFBGM5Ew71by8g9.png" alt="Pasted image 20231103112007" /></p>

<h1 id="2-寄存器">2. 寄存器</h1>
<p><img src="https://s2.loli.net/2023/11/16/oA6cr1EdYgpmN5w.png" alt="Pasted image 20231103113001" />
在<strong>x86-64</strong>系统中:
<img src="https://s2.loli.net/2023/11/16/OpwvatjVhIefYuE.png" alt="Pasted image 20231103113114" />
<img src="https://s2.loli.net/2023/11/16/ibez1wZcvCmGPEk.png" alt="Pasted image 20231103113131" />
<img src="https://s2.loli.net/2023/11/16/zgu5iwAVmBScyE1.png" alt="Pasted image 20231103113136" />
<img src="https://s2.loli.net/2023/11/16/NgYSl5ABwxtqvie.png" alt="Pasted image 20231103113141" /></p>

<h1 id="3-内存的表示方式">3. 内存的表示方式</h1>
<p><img src="https://s2.loli.net/2023/11/16/wkc7iYGEdxrhlvN.png" alt="Pasted image 20231103114034" />
<img src="https://s2.loli.net/2023/11/16/OSqZcYAWPzXQioC.png" alt="Pasted image 20231103114100" />
<img src="https://s2.loli.net/2023/11/16/Q7RkB4IHGNA2lim.png" alt="Pasted image 20231103114126" />
<img src="https://s2.loli.net/2023/11/16/G8KyLYUWoDTFXSN.png" alt="Pasted image 20231103114131" /></p>

<p>[[ics习题#2. 汇编#EXE3-finished.pdf EXE3汇编 | 内存与寄存器相关习题]]</p>
<h1 id="4-程序的运行原理">4. 程序的运行原理</h1>

<h2 id="01-程序运行时内存的状态">01: 程序运行时内存的状态:</h2>

<p><img src="https://s2.loli.net/2023/11/16/smMvg53Ixd7HpPD.png" alt="Pasted image 20231114161854" />
更详细一点的图:
<img src="https://s2.loli.net/2023/11/16/GVOWzJ4RkhTjwoH.png" alt="Pasted image 20231114162002" /></p>

<p>程序运行时,代码片段被储存在虚拟内存的 <strong>read only data</strong> 中</p>

<h2 id="02-代码的执行原理">02: 代码的执行原理</h2>

<p><strong><em>How the instructions are executed?</em></strong></p>

<ul>
  <li>%rip stores an address of memory,</li>
  <li>from the address, machine can read a whole instruction once</li>
  <li>then execute it</li>
  <li>increase %rip</li>
</ul>

<p><strong><em>%rip is also called program counter (PC)</em></strong></p>

<p>PC逐行执行指令的图例:
<img src="https://s2.loli.net/2023/11/16/HhKTA8UfRYp5a6W.png" alt="Pasted image 20231114170846" /></p>

<blockquote>
  <p>小知识点:机器是怎么知道call指令的地址在哪里呢?
注意到二进制代码中的<em>42</em>,代表的是下一条指令的地址加上42,就是跳转的地址
在这个例子中,就是400549+42=40058b,这个就是右边汇编语句对应的地址
之所以会这样,是因为机器执行完400548这条指令后,%rip移动到400549,这时候call指令发挥作用,将%rip+42,移动到需要执行的代码片段</p>
</blockquote>

<h2 id="03-栈区">03: 栈区</h2>

<p><img src="https://s2.loli.net/2023/11/16/pVicD5Lxb2FyZ7v.png" alt="Pasted image 20231114172148" />
栈区存的内容:</p>
<ul>
  <li>函数的返回地址</li>
  <li>调用函数时所传的(部分)参数</li>
  <li>局部变量
关于函数调用与栈的详细关系,见 [[#三. 函数调用的实现|函数调用的实现]]</li>
</ul>

<p>#计算机系统</p>
