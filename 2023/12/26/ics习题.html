<h1 id="1-位运算">1. 位运算</h1>
<ul>
  <li>
    <table>
      <tbody>
        <tr>
          <td>[[lab1_sol.pdf</td>
          <td>lab1位运算]]</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>
    <table>
      <tbody>
        <tr>
          <td>[[EXE1_sol.pdf</td>
          <td>EXE1位运算]]</td>
        </tr>
      </tbody>
    </table>
  </li>
  <li>[[EXE2_sol.pdf | EXE2位运算]]
    <h1 id="2-汇编">2. 汇编</h1>
    <h2 id="exe3-finishedpdf--exe3汇编">[[EXE3-finished.pdf | EXE3汇编]]</h2>
  </li>
</ul>

<h2 id="下面详细地分析exe4">下面详细地分析EXE4:</h2>
<p>![[EXE4.pdf]]</p>

<h3 id="第1问">第1问</h3>

<p>开始
	.L5是一个跳表，其顺序要严格按照switch所写
	首先要明白每一个标签对应的是哪个case
	由最开始的jump可知，.L2应该是for的条件控制语句
	跳到.L11，可知其应该为switch的分支，那势必含有跳表语句
	现在就要逐个分析每个标签下具体内容的含义了
.L4：
	第一行就是
	cmpl $0，-4(%rbp)
	前面把%rsp的值存到了%rbp里，故rbp指向栈顶，则-4(%rbp)就是栈里存放的局部变量
	和0比较，我们很容易与c语言中的 <em>if(i &gt; 0)</em> 对应，故.L4对应 case 0x1f
	下一步，根据fall through可知.L6对应 case 0x20: case 0x21:
	jump .L9可知L9是控制i++的语句，准备下一个循环
.L7：
	很明显的
		sarl $2, %eax
	对应着 i / 4
	故为case 0x22, 0x25
.L8:
	sarq $8, %rax 可知是下一条
.L3: default
故.L5应填：
	从0x1f开始建立跳表：
	.L4 //0x1f
	.L6 //0x20
	.L6 //0x21
	.L7 //0x22
	.L3 //0x23
	.L8 //0x24
	.L7 //0x25
.L11中一定含有如果大于6（或小于0）的情况，跳到.L3的语句
<strong><em>注意，这不是标准答案！！！</em></strong>
	.quad .L4
	.quad .L6 
	.quad .L6
	.quad .L7
	.quad .L3 
	.quad .L8
	.quad .L7</p>

<p>.quad表示四个word，即8个byte ^37b0a1</p>

<h3 id="第2问">第2问</h3>

<p>接下来填好8个空</p>
<ol>
  <li>$0x1f
 .L11是switch语句，用于创建跳表，故看到sub推测出是将变量减去case中最小的值（在本例中是0x1f），从而将0x1f映射到0。故填$0x1f($表示常量)</li>
  <li>$6
 接下来的cmp也是跳表创建中的常规步骤了：如果待判断的变量的值超出case的范围，即比0还要小或比最大的case值还要大，那么就直接跳到default处。此例中应填0x25 - 0x1f，即$6</li>
  <li>ja
 跳转的条件，填ja。（为什么不是jg的解释在这里：[[汇编#^fa195c | 汇编跳表越界判断使用ja的原因]]）</li>
  <li>.L5(,%rdx,8)
 上面一行的mov %eax, %eax相当于将寄存器高32为置0，而下面一行很明显是间接跳转，即前往*%rax（%rax所存内容作为指令地址）。故本行就是根据跳表计算jump的地址。基址是跳表名.L5，第一项不填，后面的偏移量填i值+每个地址站的字节数。根据前面，变量i的值存在-4(%rbp)里，紧接着movl -4(%rbp), %eax 和 movslq %eax, %rdx 把i存在了%rdx中，而跳表定义时使用了.quad .L4，![[ics习题#^37b0a1]]
 故应填 .L5(,%rdx,8)</li>
  <li>movb %dl, (%rax)
 上一行的add是+=的效果，但是结果还存在寄存器里，没有存入栈区
 存数组队首指针的是-24(%rbp)，由于是char数组，故加i表示第i项
 <strong><em>Attention:栈中存放的仅仅只是数组的头指针，即数组头的地址，真实的数组存放在内存中！！</em></strong>
 算得到的地址存放在%rax中，而计算得到的值存在%edx中，而这个值是char类型的，故只要截取最后8位（使用movb）
 故答案为 movb %dl, (%rax)</li>
  <li>$6
 将i与BUF_SIZE - 1（即7）比较。
 注意到下一条jg .L9表示如果大于就break
 那么&lt;=6就进入if
 故填$6</li>
  <li>movw 0x201f, (%rax)
 数组位置存在%rax中，我们要把0x201f赋给该地址
 由于数组转换成short类型的，因此用movw</li>
  <li>$7
 for的条件判断语句 i &lt; BUF_SIZE（8）
 小于则跳回for循环开始
 注意到这里是jle （小于等于），故填 $7</li>
</ol>

<h3 id="第3问">第3问</h3>

<p>这问与汇编无关，读c程序就可以搞懂了
但还是埋了很多坑，这个与大端序小端序，位运算等息息相关</p>

<ul>
  <li>
    <p>i = 0 
执行buf[0] = (char)((*(long *)buf) » 8);
这里将buf指针转成long型，就是获取了全部8个位置上的元素
<strong><em>Attenetion!!! 然而后面的右移是对数字操作的，而不是内存中存储的字节！
也就是说，(long *)buf是指向0x24 0xf0 0x22 0x1f 0x22 0x21 0x1f 0x21这8个位置的指针，
然而 *(long *)buf)对其取内容，得到的是一个long型的数字，
然而long型在内存中是由小端序存储的！！！！！
也就是说，得到的数字是 0x211f21221f22f024，而不是 0x24f0221f22211f21！！！</em></strong>
右移8位，得到0x001f21221f22f0，再转换为char，只取最后8位，即0xf0
即buf[0] = 0xf0</p>
  </li>
  <li>
    <p>i = 1
执行 *(short *)(&amp;buf[i]) = 0x201f;
(short *)(&amp;buf[i])指向0xf0，0x22（a[1]和a[2]）
与上面同理，这里将0x201f存到 a[1]和a[2] 中，
要转换为小端序，即a[1] = 0x1f，a[2] = 0x20</p>
  </li>
  <li>
    <p>i = 2
 执行， buf[i] |= 0xf0;
 易得buf[2] = 0xf0</p>
  </li>
  <li>
    <p>i = 3
执行 buf[i] += buf[i-1];
<strong><em>！！这里提醒，当对长度不及int的数据类型进行运算（+，-）和关系运算（&lt;）等时，
x86 - 64 会自动隐式地将类型转换为int型！！</em></strong>
也就是说，执行0x1f  0xf0得到0x10f，截断得到0x0f
<strong><em>！！这里有个巨大的坑！case 0x1f后面是没有break的，因此直接执行下一个case，</em></strong>
buf[i] |= 0xf0; 得到 a[3] = 0xff;</p>
  </li>
  <li>
    <p>i = 4
*((unsigned *)buf + i/4) = (unsigned)buf[i];
先解释一下这个语句的意思。后面的unsigned是<em>unsigned int</em>的缩写
也就是把buf[i]的char型转换为int型
前面是把指向的buf指针由char型转换为int型（站4个字节），再移动到它的第i/4个元素，
最后取其中的内容
在这个例子中是*((unsigned *)buf + 1) = (unsigned)buf[4];
buf[4] = 0x22，转换为unsigned int 是 0x00000022。
buf变为int指针后+1则往后移动4个byte，指向 a[4] -&gt; a[7];
并把这4位用0x00000022赋值
<em>再次警惕小端序！</em>
则 a[4] = 22 a[5] ~ a[7] = 0x00</p>
  </li>
  <li>
    <p>i = 5
default。同上，a[5] = 0x1f，a[6] = 0x20</p>
  </li>
  <li>
    <p>i = 6
同上，a[6] = 0xf0</p>
  </li>
  <li>
    <p>i = 7
default，不执行，不变</p>
  </li>
</ul>

<p>最后的结果是：</p>

<table>
  <thead>
    <tr>
      <th>数组下标</th>
      <th>0</th>
      <th>1</th>
      <th>2</th>
      <th>3</th>
      <th>4</th>
      <th>5</th>
      <th>6</th>
      <th>7</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>存储的值</td>
      <td>0xf0</td>
      <td>0x1f</td>
      <td>0xf0</td>
      <td>0xff</td>
      <td>0x22</td>
      <td>0x1f</td>
      <td>0xf0</td>
      <td>0x00</td>
    </tr>
  </tbody>
</table>

<table>
  <tbody>
    <tr>
      <td>[[EXE4-sildes.pdf</td>
      <td>详细步骤]]</td>
    </tr>
    <tr>
      <td>[[EXE4_sol.pdf</td>
      <td>答案]]</td>
    </tr>
  </tbody>
</table>

<p>学习</p>

<p>#计算机系统 #习题</p>
